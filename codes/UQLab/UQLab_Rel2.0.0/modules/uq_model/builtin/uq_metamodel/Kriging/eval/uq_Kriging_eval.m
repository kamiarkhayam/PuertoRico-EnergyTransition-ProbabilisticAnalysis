function [YMu,YSigma2,YCov] = uq_Kriging_eval(current_model,X0)%UQ_KRIGING_EVAL evaluates the responses of the Kriging metamodel at X0.%%   YMU = UQ_KRIGING_EVAL(CURRENT_MODEL,X0) evaluates the response of the%   Kriging metamodel CURRENT_MODEL (i.e., Kriging predictor mean)%   at given inputs X0.%%   [YMU,YSIGMA2] = UQ_KRIGING_EVAL(...) additionally returns the variance%   of the Kriging predictor at X0.%%   [YMU,YSIGMA2,YCOV] = UQ_KRIGING_EVAL(...) additionally returns the%   full covariace matrix of the Kriging predictor at X0.%%   See also UQ_EVAL_UQ_METAMODEL, UQ_KRIGING_CALCULATE.%   Note:%%   - For backward compatibility, 'R' instead of 'C', even when refering%     to correlation matrices (i.e., in the case of a heteroscedastic%     regression model), are used everywhere in the implementation.%   - The function is implemented for performance, therefore no external%     function calls are used extensively.%% Check inputsnarginchk(2,2)% Do nothing if X0 is emptyif isempty(X0)    YMu = [];    YSigma2 = [];    YCov = [];    returnend% Get dimensions of X0[~,M0] = size(X0);% Make sure that X0 dimensions are consistent with the experimental designif M0 ~= current_model.Internal.Runtime.M   error(['Inconsistent dimensions of supplied input',...       ' with respect to the experimental design!']) end%% Make sure that current_model is calculated, but only if it isn't customif ~current_model.Internal.Runtime.isCalculated && ...        ~current_model.Internal.Runtime.isCustom    uq_calculateMetamodel(current_model);end%% Map X0 to the appropriate space to get U0SCALING = current_model.Internal.Scaling;SCALING_BOOL = isa(SCALING, 'double') || isa(SCALING, 'logical') || ...    isa(SCALING, 'int');        if SCALING_BOOL && SCALING    muX = current_model.Internal.ExpDesign.muX;    sigmaX = current_model.Internal.ExpDesign.sigmaX;    U0 = bsxfun(@rdivide, (bsxfun(@minus, X0, muX)), sigmaX);elseif SCALING_BOOL && ~SCALING    U0 = X0;endif ~SCALING_BOOL    % In that case, SCALING is an INPUT object.    % An isoprobabilistic transform is performed    % from: current_model.Internal.Input    % to  : current_model.Internal.Scaling    U0 = uq_GeneralIsopTransform(X0,...        current_model.Internal.Input.Marginals,...        current_model.Internal.Input.Copula,...        SCALING.Marginals, SCALING.Copula);end%% Retrieve the necessary matricesF = current_model.Internal.Kriging(1).Trend.F;  % Information matrixU = current_model.ExpDesign.U;  % Scaled training inputs%% Filter out the constants from the experimental designnonConstIdx = current_model.Internal.Runtime.nonConstIdx;U0 = U0(:,nonConstIdx);U = U(:,nonConstIdx);%% Initialize the predictor outputs% Store the input and output size to local variablesNout = current_model.Internal.Runtime.Nout;N0 = size(U0,1);% Initialize outputsYMu = zeros(N0,Nout);if nargout >= 2    YSigma2 = zeros(N0,Nout);endif nargout >= 3    YCov = zeros(N0,N0,Nout);end%% Calculate f0 (the trend basis functions value for the input U0)evalF_handle = current_model.Internal.Kriging(1).Trend.Handle;f0 = evalF_handle(U0,current_model);%% Cycle through each output and compute the predictionfor oo = 1:Nout     %% Retrieve necessary quantities as local variables    Y = current_model.ExpDesign.Y(:,oo);    theta = current_model.Internal.Kriging(oo).Optim.Theta;    beta = current_model.Internal.Kriging(oo).Trend.beta;    evalR_handle = current_model.Internal.Kriging(oo).GP.Corr.Handle;    R = current_model.Internal.Kriging(oo).GP.R;    sigmaSQ = current_model.Internal.Kriging(oo).GP.sigmaSQ;    GPCorrOptions = current_model.Internal.Kriging(oo).GP.Corr;    %% Retrieve quantities for Kriging regression    if isfield(current_model.Internal,'Regression')        sigmaNSQ = current_model.Internal.Regression(oo).SigmaNSQ;        if current_model.Internal.Regression(oo).IsRegression            if current_model.Internal.Regression(oo).IsHomoscedastic                % If sigmaNSQ is known to be constant everywhere, work with tau                % NOTE: R is already adjusted with tau                sigmaTotSQ = sigmaNSQ + sigmaSQ;                tau = sigmaNSQ/sigmaTotSQ;            else                 % If sigmaNSQ are known at different points, work with cov.                % NOTE: For compatibility, keep the name 'R' instead of 'C'                R = sigmaSQ * R;                if iscolumn(sigmaNSQ)                     R = R + diag(sigmaNSQ);                else                     R = R + sigmaNSQ;                end            end        end    end    %% Retrieve auxiliary matrices; If the cache is empty, calculate them    if isempty(current_model.Internal.Kriging(oo).Cached)        auxMatrices = uq_Kriging_calc_auxMatrices(R, F, Y, 'default');    else        auxMatrices = current_model.Internal.Kriging(oo).Cached;    end    % Retrieve some auxiliary matrices    FTRinv = auxMatrices.FTRinv;   % F^T * R^(-1)    FTRinvF = auxMatrices.FTRinvF; % F^T * R^(-1) * F    %% Compute r0, cross-correlation (resp. covariance)    %  between the given inputs U0 and training points U    % This is the cross correlation matrix, nugget should not be applied.    CrossCorOpts = GPCorrOptions;    CrossCorOpts.Nugget = 0;  % force nugget to 0    r0 = evalR_handle(U0, U, theta, CrossCorOpts);    %% Adjust the cross-correlation/covariance for regression model    if isfield(current_model.Internal,'Regression')       if current_model.Internal.Regression(oo).IsRegression            if current_model.Internal.Regression(oo).IsHomoscedastic                % Homogeneous noise case with tau                r0 = (1-tau) * r0;            else                % Heterogenous noise casee                r0 = sigmaSQ * r0;            end       end    end    %% Compute the mean of Kriging predictor    %  YMu = f0*beta + r0 * R^(-1) * (Y - F*beta)    if any(isnan(auxMatrices.cholR(:)))        Rinv = auxMatrices.Rinv;  % pseudo-inverse of R    else        L = auxMatrices.cholR;        Rinv = L \ (transpose(L) \ eye(size(L)));    end    YMu(:,oo) = f0*beta + r0 * Rinv * (Y - F*beta);    %% Compute the variance of the Kriging predictor    %  YSigma2 = sigma2 * (1 - D1 + D2)    u0 = FTRinv * transpose(r0) - transpose(f0);    if nargout == 2        % Compute the part: D1 = r0 * R^(-1) * transpose(r0)        % NOTE: Only need the diagonal elements of the resulting matrix        % r0 is Ntest-by-N and R^(-1) is N-by-N        D1 = uq_Kriging_calc_DiagOfCongruent(r0,R);        % Compute the part: D2 = u0^T * (F^T*R^(-1)*F)^(-1) * u0        % NOTE: Only need the diagonal elements of the resulting matrix        % u0 is P-by-Ntest and (F^T*R^(-1)*F)^(-1) is P-by-P, so        % transpose first following the function contract.        D2 = uq_Kriging_calc_DiagOfCongruent(transpose(u0),FTRinvF);        % Calculate the variance of the predictor        % or its the MSE (Mean Squared Error)        if isfield(current_model.Internal,'Regression') && ...                current_model.Internal.Regression(oo).IsRegression            if current_model.Internal.Regression(oo).IsHomoscedastic                % Homoscedastic case, tau is available                YSigmaOO = sigmaTotSQ * (ones(size(D1))-D1+D2);            else                % Heteroscedastic case                YSigmaOO = sigmaSQ - D1 + D2;            end        else            % Interpolation case            YSigmaOO = sigmaSQ * (ones(size(D1))-D1+D2);        end        YSigma2(:,oo) = verify_YSigma2(YSigmaOO);    end    %% Compute the full covariance matrix    %  YCov = sigma2 * (CorrU0 - D1 + D2)    if nargout == 3        % Compute the part: D1 = r0 * R^(-1) * transpose(r0)        % NOTE: Need all the elements of the matrix!        D1 = r0 * Rinv * transpose(r0);        % Compute the part: u0^T * (F^T*R^(-1)*F)^(-1) * u0        % NOTE: Need all the elements of the resulting matrix!        D2 = transpose(u0) * (FTRinvF \ u0);        CorrU0 = evalR_handle(U0, U0, theta, GPCorrOptions);        if isfield(current_model.Internal,'Regression') && ...                    current_model.Internal.Regression(oo).IsRegression            if current_model.Internal.Regression(oo).IsHomoscedastic                % Homoscedastic case, tau is available                CorrU0 = (1-tau) * CorrU0;  % Adjusted correlation                YCovOO = sigmaTotSQ * (CorrU0-D1+D2+tau*eye(size(D1,1)));            else                % Heteroscedastic case                % NOTE: D1 and D2 are not multiplied with variance;                % variance information is already embedded in                % D1 and D2 as they are computed using covariance.                 YCovOO = sigmaSQ*CorrU0 - D1 + D2;            end        else            % Interpolation case            YCovOO = sigmaSQ * (CorrU0-D1+D2);        end        YCov(:,:,oo) = YCovOO;        YSigmaOO = diag(YCovOO);  % Get the variance in the diagonal        YSigma2(:,oo) = verify_YSigma2(YSigmaOO);    end    %% If requested, clean the cache    if ~current_model.Internal.KeepCache        current_model.Internal.Kriging(oo).Cached = [];    endendendfunction YSigma2 = verify_YSigma2(YSigma2)%Verify the variance of the Kriging predictor.if any(YSigma2 < 0)    warning(...        ['Numerical dispersion: calculated sigma has',...            ' negative value for %d out of %d predicted values!\n',...            'The smallest of which is: %5.4e.'],...        sum(YSigma2 < 0), numel(YSigma2), min(YSigma2))end% Cap negative variance to zero, but don't omit NaN.% By default, max([0,nan]) = 0, but having nan may indicate serious issues.% NOTE: Buffer underflow possible, needs fixing!% NOTE: max(0, YSigma2, 'includenan') is not supported in R2014a.isNaNIdx = isnan(YSigma2);YSigma2 = max(0,YSigma2);YSigma2(isNaNIdx) = nan;end